<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VotoElectronico: Voto Electrónico</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VotoElectronico&#160;<span id="projectnumber">Entrega1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Voto Electrónico </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Grupo Furlong:</p>
<ul>
<li>Facundo Rossi (padrón 86.707 - <a href="mailto:frossi85@gmail.com">frossi85@gmail.com</a>)</li>
<li>Leandro Miguenz (padrón 90.649 - <a href="mailto:leandro.v.059@gmail.com">leandro.v.059@gmail.com</a>)</li>
<li>Martín Lucero (padrón 89.630 - <a href="mailto:don_pipa182@yahoo.com">don_pipa182@yahoo.com</a>)</li>
<li>Miguel Torres (padrón 91.396 - <a href="mailto:mat1204@hotmail.com">mat1204@hotmail.com</a>)<br/>
 <hr/>
</li>
</ul>
<h2><a class="anchor" id="imple"></a>
Implementación</h2>
<p>Debido a que la problemática que presentan las distintas entidades del dominio son diferentes, se utilizaran distintos tipo de organizaciones y estructuras de datos de acuerdo a la entidad. <br/>
<br/>
</p>
<p>Aparte del ID de cada entidad, se introducirá uno numérico (entero). De esta manera se lograra una mejor performance en búsquedas, y una implementación mas sencilla de los algoritmos de las estructuras de archivos.<br/>
 Además solucionaría problemas de tamaño de almacenamiento dados por almacenar entidades enteras dentro de otra entidad que las referencia, como es el caso de votante que contienen elecciones indefinidas. <br/>
<br/>
</p>
<p>Tanto el ID que agregamos nosotros, como el identificador de la clase (x ej en votante el DNI), no podrán tener duplicados. Por eso al realizar cualquier alta o modificación, se deberá comprobar que sean únicos. <br/>
<br/>
</p>
<p>Si se cambia el identificador (o parte de él) de una instancia particular de cualquier tipo de entidad, antes de eso se deberán actualizar los índices que relacionen la clave autonumerica con el identificador de la instancia, modificando este ultimo con el nuevo valor. Lo mismo si se borra una entidad, primero se actualizan los índices y luego se elimina.</p>
<h2><a class="anchor" id="orga"></a>
Organización</h2>
<p>Nueva definición de las entidades:<br/>
<br/>
</p>
<ul>
<li><a class="el" href="classDistrito.html">Distrito</a> (id, (distrito)i)</li>
<li><a class="el" href="classVotante.html">Votante</a> (id, (DNI)i, NombreyApellido, clave, domicilio, (idDistrito)ie, ((idEleccion)ie)*)</li>
<li><a class="el" href="classEleccion.html">Eleccion</a> (id, (fecha, (idCargo)ie)i, ((idDistrito)ie)+)</li>
<li><a class="el" href="classLista.html">Lista</a> (id, ((idEleccion)ie, nombre)i)</li>
<li><a class="el" href="classCandidato.html">Candidato</a> (id, ((idLista)ie, (idVotante)ie, (idCargo)ie)i)</li>
<li><a class="el" href="classCargo.html">Cargo</a> (id, (cargo)i, (cargo)*)</li>
<li><a class="el" href="classConteo.html">Conteo</a> (((idLista)ie, (idDistrito)ie, (idEleccion)ie)i, cantidad) <br/>
 (<a class="el" href="classConteo.html">Conteo</a> no necesita id numérico ya que ninguna otra entidad tiene referencias a ella. Relacionamos directamente la clave con el offset en el archivo de conteos)</li>
</ul>
<p>Estructuras utilizadas:</p>
<p>Estructuras del TP (cuando se usa la palabra id, se refiere a la clave autonumerica):</p>
<p>1- Hash Votante/id =  clave: DNI (pasar de int a string), dato: id del votante <br/>
 2- Hash idVotante/offset =  clave: id_votante, dato: offset del votante en el archivo <br/>
</p>
<p>3- Hash Distrito/id = clave: nombreDistrito (string), dato: id del distrito<br/>
 4- Hash idDistrito/offset = clave: id_distrito, dato: offset del distrito en el archivo <br/>
</p>
<p>5- Hash Cargo/id = clave: cargoPrincipal (string), dato: id del cargo<br/>
 6- Hash idCargo/offset: clave: id_cargo, dato: offset del cargo en el archivo <br/>
</p>
<p>7- Arbol Candidato/id = clave: fecha$cargoPpal$nombreLista$DNI(string). dato: id del candidato<br/>
 8- Hash idCandidato/offset = clave: id_candidato, dato: offset del candidato en el archivo <br/>
</p>
<p>9- Arbol Lista/id = clave: fecha$cargoPpal$nombreLista. dato: id de la lista. (el $ es el símbolo que usamos para concatenar las cadenas)<br/>
 10- Hash idLista/offset = clave: id_lista, dato: offset de la lista en el archivo <br/>
</p>
<p>11- Arbol Eleccion/id = clave: fecha$cargoPrincipal . dato: id_eleccion.<br/>
 12- Hash idEleccion/offset = clave: id_eleccion . dato: offset en el archivo <br/>
</p>
<p>13- ARBOL REPORTE DISTRITO = clave: nom_distrito$fecha$cargoPrincipal$nom_lista. dato: offset del conteo en el archivo.<br/>
 14- ARBOL REPORTE LISTA = clave: fecha$cargoPrincipal$nom_lista$nom_distrito. dato: offset del conteo en el archivo.<br/>
 15- ARBOL REPORTE ELECCION = clave: fecha$cargoPrincipal$nom_distrito$nom_lista. dato: offset del conteo en el archivo.<br/>
</p>
<p>Todas las entidades se almacenan en archivos de registros de tamaño variable.<br/>
 En el caso de aquellas que implementan id numérico, se utiliza un hash para relacionar ese id con su correspondiente clave.<br/>
 Es decir que primero se le pasa su id a dicho hash para obtener la clave, y luego se le pasa esa clave al hash/árbol índice de esa entidad, para finalmente obtener el offset del registro en su archivo de registros variables. <br/>
<br/>
</p>
<p>Para las entidades que tienen más de un campo como identificador (Elección, <a class="el" href="classLista.html">Lista</a> y <a class="el" href="classCandidato.html">Candidato</a>), se utilizan índices B+, para aprovechar la posibilidad de hacer búsquedas aproximadas que brinda esa estructura. <a class="el" href="classDistrito.html">Distrito</a>, <a class="el" href="classVotante.html">Votante</a> y <a class="el" href="classCargo.html">Cargo</a> usan índices de dispersión extensible modular.</p>
<p>En el caso particular de <a class="el" href="classConteo.html">Conteo</a>, tiene tres índices B+, para posibilitar la recuperación de conteos por lista, distrito o elección, y usarlos para imprimir el reporte de resultados en base a alguno de esos tres criterios.<br/>
<br/>
</p>
<p>Los conteos se crean todos con cantidad 0 cuando se da de alta una lista. Cuando se confirma el voto del usuario, a partir de su distrito y de la lista que votó se obtiene el conteo correspondiente (buscándolo en el árbol) y se incrementa su cantidad de votos. <hr/>
<h2><a class="anchor" id="res"></a>
Resumen:</h2>
<ul>
<li>Los datos (las entidades propiamente dichas) se guardaran en archivos de registros variables o fijos (según de qué entidad se trate).</li>
<li>La búsqueda de estos datos se realizará mediante índices implementados con un hash extensible y un árbol B+, que van a guardar un par (clave, offset en archivo).</li>
<li>El flujo del programa tendría esta forma:<br/>
 1- el administrador ingresa una clave.<br/>
 2- el hash/árbol usado cómo índice recibe ese id, y devuelve un offset.<br/>
 3- se accede a ese offset para obtener el registro deseado.<br/>
 4- el administrador modifica el registro.<br/>
 5 - Se persisten los cambios, y si es necesario, se modifica el offset en el hash/árbol índice. <br/>
<br/>
 (Para altas, bajas y votaciones la estructura es similar).<br/>
 <hr/>
 </li>
</ul>
<h2><a class="anchor" id="notas"></a>
Sobre el formato de las claves</h2>
<p>Aclaraciones:<br/>
<br/>
</p>
<p>1 - Cuando se guarda una clave en el hash o arbol, antes se llama a Utilidaes::formatearClave(clave) para reemplazar los espacios por '&amp;'.<br/>
</p>
<p>2 - Para las claves con fechas, tambien antes de guardarlas se le hace a la fecha Utilidades::indexarFecha(fecha) para llevarla al formato aaaammdd (la fecha original ingresada por el administrador debe ser del formato ddmmaaaa o dd/mm/aaaa. No es valido un formato d/m/aaaa, es decir, debe completarse con ceros si es menor a 10.<br/>
   3 - También cuando una clave es compuesta, se concatenan los strings con '$'.<br/>
<br/>
</p>
<p>Ejemplo ilustrativo: el administrador habia insertado una lista con fecha "20/10/2011", cargo "Diputado Cordoba", nombre "UCR". El ABMentidades::altaLista inserta la clave en la forma "20111020$Diputado&amp;Cordoba$UCR".<br/>
<br/>
</p>
<ul>
<li><a class="el" href="classDistrito.html">Distrito</a>: "nombre_distrito" | Ejemplo: "Lanus"<br/>
</li>
<li><a class="el" href="classCargo.html">Cargo</a>: "nombre_cargo" | Ejemplo: "Intendente&amp;Lanus"<br/>
</li>
<li><a class="el" href="classEleccion.html">Eleccion</a>: "fecha$cargo" | Ejemplo: "20111020$Intendente&amp;Lanus"<br/>
</li>
<li><a class="el" href="classLista.html">Lista</a>: "fecha$cargo$nombreLista" | Ejemplo: "20111020$Intendente&amp;Lanus$UCR"<br/>
</li>
<li><a class="el" href="classVotante.html">Votante</a>: "DNI" | Ejemplo: "34094150"<br/>
</li>
<li><a class="el" href="classCandidato.html">Candidato</a>: "fecha$cargo$nombreLista$DNI" | Ejemplo: "20111020$Intendente&amp;Lanus$UCR$34094150"<br/>
</li>
</ul>
<hr/>
 <h2><a class="anchor" id="ind"></a>
Índices</h2>
<h2><a class="anchor" id="hash"></a>
Hash:</h2>
<ul>
<li>Función de hashing utilizada:<br/>
<br/>
</li>
</ul>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash_extensible::funcion_hashing(<a class="code" href="classRegistroIndice.html" title="Registros utilizados por los índices implementados con el árbol B+ y el hash extensible.">RegistroIndice</a> *registro){

        <span class="keywordtype">string</span> clave = registro-&gt;<a class="code" href="classRegistroIndice.html#a9e398fb8bd9b8a93d98ecd3f4994c1c7" title="Devuelve la clave del registro.">getClave</a>();
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tam_tabla = obtener_tamanio_tabla();

        <span class="keywordtype">int</span> valor = 0;

   <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; clave.length() ; i++ )
        valor = 37 * valor + clave.at( i );

    valor %= tam_tabla;
    <span class="keywordflow">if</span>( valor &lt; 0 )
        valor += tam_tabla;

    <span class="keywordflow">return</span> valor + 1;
} 
</pre></div><p>En un principio usamos una función mucho más simple, que obtenía el valor ASCII de los caracteres de la clave, los sumaba, y luego calculaba el módulo de ese valor con el tamaño de la tabla de dispersión. Esa función dio malos resultados al intentar guardar grandes cantidades de registros en el hash, volviendo demasiado lenta y casi imposible la inserción de más de 500 registros, aproximadamente, debido a la cantidad de colisiones que se producían. <br/>
<br/>
</p>
<p>Con la actual función de hashing los resultados fueron mucho mejores, y pudimos insertar hasta 1 millón de registros en un tiempo de ejecución razonable.</p>
<ul>
<li>Tamaño de bloques:<br/>
<br/>
</li>
</ul>
<p>Para los bloques del hash elegimos un tamaño de 512 bytes, porque es un múltiplo de 512*2^n, al igual que los bloques en que está organizaod el disco, lo que permite aprovechar mejor el buffering del sistema.<br/>
 Además consideramos que es un tamaño adecuado a nuestras necesidades, ya que los bloques del hash almacenan objetos de la clase <a class="el" href="classRegistroIndice.html" title="Registros utilizados por los índices implementados con el árbol B+ y el hash extensible.">RegistroIndice</a>, que una vez persistidos con sus metadatos, ocupan un estimado de entre 13 y 18 bytes cada uno, y por lo tanto en cada bloque caben más de 30 registros.</p>
<h2><a class="anchor" id="arbol"></a>
Árbol B+:</h2>
<ul>
<li>Registros:<br/>
<br/>
</li>
</ul>
<p>El registro consta de 3 atributos, una clave(string), un offset u id(long) y un atributo denominado link (long) que es como indica su nombre es un link directo al registro indmediatamente mayor a él. Este último atributo se implementa para realizar el recorrido secuencial desde un registro en vez de hacerlo desde un nodo.<br/>
 Los unicos campos variables dentro los registros del árbol son las claves, que son del tipo string. Para este tipo de dato se graba el largo de la clave como un entero (int), sin contar el '/0'. Seguido de eso se procede a guardar cada caracter del string sin tener en cuenta el caracter de finalización. <br/>
<br/>
</p>
<ul>
<li>Nodos:<br/>
<br/>
</li>
</ul>
<p>El nodo posee como atributos su tamaño máximo, la cantidad de registros que puede albergar, los registros mismos, una dirección dentro del archivo del árbol, una dirección al padre, una al nodo inmediatamente menor y un flag que es utilizado para indicar si el nodo fue modificado después de leerlo del archivo del árbol. Este último es utilizado para implementar una política de caché tal que al leer un nodo, se guarda en memoria y mientras no se supere la cantidad máxima de nodos en memoria seteados por el árbol no se impacten los cambios, ni se lea un nodo desde el disco si está en cachá. Además se provee de un mecanismo interno que permite obligar a impactar los cambios y liberar. Este es útil en casos como por ejemplo al cerrar o eliminar el árbol.<br/>
 Como se describió antes, el encargado de saber la ubicación de un registro mayor, pertenece al registro mismo, por lo que no se incluye en el nodo el link al nodo hermano.<br/>
 Para la búsqueda de registros dentro de un nodo en memoria se utilizó búsqueda binaria, la cual en memoria es muy eficiente debido a que los registros estan ordenados.<br/>
<br/>
</p>
<ul>
<li>Reestructuración por overflow y underflow:<br/>
<br/>
</li>
</ul>
<p>El split y la combinación de nodos se realiza a nivel del árbol. Es decir que no es un método implementado en la clase <a class="el" href="classNodo.html">Nodo</a>.<br/>
 Para la combinación, se fusionan los dos nodos sobre el nodo izquierdo y se libera el nodo derecho. Esta operación de combinar nodo se utiliza por el rebalancear nodo, que va rebalancenado el árbol desde el primer nodo en el que hay que combinar un nodo hasta llegar a la raíz o que no halla que combinar.<br/>
 El split es similar, se busca el nodo donde debería insertarse el registro; si necesita ser partido, se parte y se extiende la partición desde el nodo hacia arriba o sus menores.</p>
<hr/>
 <h2><a class="anchor" id="bugs"></a>
Bugs conocidos</h2>
<p>Hash: <br/>
<br/>
</p>
<ul>
<li>Quedan algunas pérdidas de memoria sin resolver. Según las pruebas hechas, insertar 1 millón de registros de una vez consume 3 Gb de RAM. Sin embargo, para inserciones de menos de 300.000 elementos, la pérdida de memoria es mucho menor, y se pueden realizar sin problemas en una computadora con 2 o más Gb de RAM. Independientemente de la memoria del sistema, se puede guardar cualquier cantidad de registros, siempre y cuando no se los guarde a todos en una sola corrida (es decir, guardando algunos, cerrando el programa y guardando los que faltan). <br/>
<br/>
</li>
</ul>
<p>Bajas: <br/>
<br/>
</p>
<ul>
<li>Las bajas funcionan bien eliminando los indices. Lo que no llegamos a hacer es arreglar el caso de que al dar de baja un indice id/offset de alguna entidad, las otras entidades que la referenciaban, cuando quieran levantar a memoria la entidad a que referenciaban, no la van a encontrar porque no va a estar en el hash id/offset. Lo que puede llegar a pasar es que se lancen excepciones cuando no se encuentre un id. <br/>
<br/>
</li>
</ul>
<p>Votación: <br/>
<br/>
</p>
<ul>
<li>El método getListaPorEleccion() está devolviendo las listas de la elección que recibe por parámetro y de la siguiente elección en fecha. Puede deberse a una inconsistencia de datos de la carga inicial, no se llego a corroborar. </li>
</ul>
</div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Oct 21 2011 22:48:19 for VotoElectronico by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
