<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VotoElectronico: Voto Electrónico</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VotoElectronico&#160;<span id="projectnumber">Entrega1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Voto Electrónico </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Authors:</b></dt><dd>Grupo Furlong:<ul>
<li>Facundo Rossi (padrón 86.707 - <a href="mailto:frossi85@gmail.com">frossi85@gmail.com</a>)</li>
<li>Leandro Miguenz (padrón 90.649 - <a href="mailto:leandro.v.059@gmail.com">leandro.v.059@gmail.com</a>)</li>
<li>Martín Lucero (padrón 89.630 - <a href="mailto:don_pipa182@yahoo.com">don_pipa182@yahoo.com</a>)</li>
<li>Miguel Torres (padrón 91.396 - <a href="mailto:mat1204@hotmail.com">mat1204@hotmail.com</a>)</li>
<li>Pablo Arlia (padrón xx.xxx - <a href="mailto:pablo.arlia@gmail.com">pablo.arlia@gmail.com</a>)<br/>
 <hr/>
</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="imple"></a>
Implementación</h2>
<p>Debido a que la problemática que presentan las distintas entidades del dominio son diferentes, se utilizaran distintos tipo de organizaciones y estructuras de datos de acuerdo a la entidad. <br/>
<br/>
</p>
<p>Aparte del ID de cada entidad, se introducirá uno numérico (entero). De esta manera se lograra una mejor performance en búsquedas, y una implementación mas sencilla de los algoritmos de las estructuras de archivos.<br/>
 Además solucionaría problemas de tamaño de almacenamiento dados por almacenar entidades enteras dentro de otra entidad que las referencia, como es el caso de votante que contienen elecciones indefinidas. <br/>
<br/>
</p>
<p>Tanto el ID que agregamos nosotros, como el identificador de la clase (x ej en votante el DNI), no podrán tener duplicados. Por eso al realizar cualquier alta o modificación, se deberá comprobar que sean únicos. <br/>
<br/>
</p>
<p>Si se cambia el identificador (o parte de él) de una instancia particular de cualquier tipo de entidad, antes de eso se deberán actualizar los índices que relacionen la clave autonumerica con el identificador de la instancia, modificando este ultimo con el nuevo valor. Lo mismo si se borra una entidad, primero se actualizan los índices y luego se elimina.</p>
<h2><a class="anchor" id="orga"></a>
Organización</h2>
<p>Nueva definición de las entidades:<br/>
<br/>
</p>
<ul>
<li><a class="el" href="classDistrito.html">Distrito</a> (id, (distrito)i)</li>
<li><a class="el" href="classVotante.html">Votante</a> (id, (DNI)i, NombreyApellido, clave, domicilio, (idDistrito)ie, ((idEleccion)ie)*)</li>
<li><a class="el" href="classEleccion.html">Eleccion</a> (id, (fecha, (idCargo)ie)i, ((idDistrito)ie)+)</li>
<li><a class="el" href="classLista.html">Lista</a> (id, ((idEleccion)ie, nombre)i)</li>
<li><a class="el" href="classCandidato.html">Candidato</a> (id, ((idLista)ie, (idVotante)ie, (idCargo)ie)i)</li>
<li><a class="el" href="classCargo.html">Cargo</a> (id, (cargo)i, (cargo)*)</li>
<li><a class="el" href="classAdministrador.html">Administrador</a> (id, (usuario)i, clave)</li>
<li><a class="el" href="classConteo.html">Conteo</a> (((idLista)ie, (idDistrito)ie, (idEleccion)ie)i, cantidad) <br/>
 (<a class="el" href="classConteo.html">Conteo</a> no necesita id numérico ya que ninguna otra entidad tiene referencias a ella. Relacionamos directamente la clave con el offset en el archivo de conteos)</li>
</ul>
<p>Estructuras utilizadas:</p>
<p>Estructuras del TP (cuando se usa la palabra id, se refiere a la clave autonumerica):</p>
<p>1- Hash Votante/id =  clave: DNI (pasar de int a string), dato: id del votante <br/>
 2- Hash idVotante/offset =  clave: id_votante, dato: offset del votante en el archivo <br/>
</p>
<p>3- Hash Distrito/id = clave: nombreDistrito (string), dato: id del distrito<br/>
 4- Hash idDistrito/offset = clave: id_distrito, dato: offset del distrito en el archivo <br/>
</p>
<p>5- Hash Cargo/id = clave: cargoPrincipal (string), dato: id del cargo<br/>
 6- Hash idCargo/offset: clave: id_cargo, dato: offset del cargo en el archivo <br/>
</p>
<p>7- Arbol Candidato/id = clave: fecha$cargoPpal$nombreLista$DNI(string). dato: id del candidato<br/>
 8- Hash <a class="el" href="classCandidato.html">Candidato</a> = clave: id_candidato, dato: offset del candidato en el archivo <br/>
</p>
<p>9- Arbol Lista/id = clave: fecha$cargoPpal$nombreLista. dato: id de la lista. (el $ es el símbolo que usamos para concatenar las cadenas)<br/>
 10- Hash idLista/offset = clave: id_lista, dato: offset de la lista en el archivo <br/>
</p>
<p>11- Arbol Eleccion/id = clave: fecha$cargoPrincipal . dato: id_eleccion.<br/>
 12- Hash idEleccion/offset = clave: id_eleccion . dato: offset en el archivo <br/>
</p>
<p>13- ARBOL REPORTE DISTRITO = clave: nom_distrito$fecha$cargoPrincipal$nom_lista. dato: offset del conteo en el archivo.<br/>
 14- ARBOL REPORTE LISTA = clave: fecha$cargoPrincipal$nom_lista$nom_distrito. dato: offset del conteo en el archivo.<br/>
 15- ARBOL REPORTE ELECCION = clave: fecha$cargoPrincipal$nom_distrito$nom_lista. dato: offset del conteo en el archivo.<br/>
</p>
<p>Todas las entidades se almacenan en archivos de registros de tamaño variable.<br/>
 En el caso de aquellas que implementan id numérico, se utiliza un hash para relacionar ese id con su correspondiente clave.<br/>
 Es decir que primero se le pasa su id a dicho hash para obtener la clave, y luego se le pasa esa clave al hash/árbol índice de esa entidad, para finalmente obtener el offset del registro en su archivo de registros variables. <br/>
<br/>
</p>
<p>Para las entidades que tienen más de un campo como identificador (Elección, <a class="el" href="classLista.html">Lista</a> y <a class="el" href="classCandidato.html">Candidato</a>), se utilizan índices B+, para aprovechar la posibilidad de hacer búsquedas aproximadas que brinda esa estructura. <a class="el" href="classDistrito.html">Distrito</a>, <a class="el" href="classVotante.html">Votante</a>, <a class="el" href="classCargo.html">Cargo</a> y <a class="el" href="classAdministrador.html">Administrador</a> usan índices de dispersión extensible modular.</p>
<p>En el caso particular de <a class="el" href="classConteo.html">Conteo</a>, tiene tres índices B+, para posibilitar la recuperación de conteos por lista, distrito o elección, y usarlos para imprimir el reporte de resultados en base a alguno de esos tres criterios.</p>
<hr/>
<h2><a class="anchor" id="res"></a>
Resumen:</h2>
<ul>
<li>Los datos (las entidades propiamente dichas) se guardaran en archivos de registros variables o fijos (según de qué entidad se trate).</li>
<li>La búsqueda de estos datos se realizará mediante índices implementados con un hash extensible y un árbol B+, que van a guardar un par (clave, offset en archivo).</li>
<li>El flujo del programa tendría esta forma:<br/>
 1- el administrador ingresa una clave.<br/>
 2- el hash/árbol usado cómo índice recibe ese id, y devuelve un offset.<br/>
 3- se accede a ese offset para obtener el registro deseado.<br/>
 4- el administrador modifica el registro.<br/>
 5 - Se persisten los cambios, y si es necesario, se modifica el offset en el hash/árbol índice. <br/>
<br/>
 (Para altas, bajas y votaciones la estructura es similar).<br/>
 <hr/>
 </li>
</ul>
<h2><a class="anchor" id="notas"></a>
Sobre el formato de las claves</h2>
<p>Aclaraciones:<br/>
<br/>
</p>
<p>1 - Cuando se guarda una clave en el hash o arbol, antes se llama a Utilidaes::formatearClave(clave) para reemplazar los espacios por '&amp;'.<br/>
</p>
<p>2 - Para las claves con fechas, tambien antes de guardarlas se le hace a la fecha Utilidades::indexarFecha(fecha) para llevarla al formato aaaammdd (la fecha original ingresada por el administrador debe ser del formato ddmmaaaa o dd/mm/aaaa. No es valido un formato d/m/aaaa, es decir, debe completarse con ceros si es menor a 10.<br/>
   3 - También cuando una clave es compuesta, se concatenan los strings con '$'.<br/>
<br/>
</p>
<p>Ejemplo ilustrativo: el administrador habia insertado una lista con fecha "20/10/2011", cargo "Diputado Cordoba", nombre "UCR". El ABMentidades::altaLista inserta la clave en la forma "20111020$Diputado&amp;Cordoba$UCR".<br/>
<br/>
</p>
<ul>
<li><a class="el" href="classDistrito.html">Distrito</a>: "nombre_distrito" | Ejemplo: "Lanus"<br/>
</li>
<li><a class="el" href="classCargo.html">Cargo</a>: "nombre_cargo" | Ejemplo: "Intendente&amp;Lanus"<br/>
</li>
<li><a class="el" href="classEleccion.html">Eleccion</a>: "fecha$cargo" | Ejemplo: "20111020$Intendente&amp;Lanus"<br/>
</li>
<li><a class="el" href="classLista.html">Lista</a>: "fecha$cargo$nombreLista" | Ejemplo: "20111020$Intendente&amp;Lanus$UCR"<br/>
</li>
<li><a class="el" href="classVotante.html">Votante</a>: "DNI" | Ejemplo: "34094150"<br/>
</li>
<li><a class="el" href="classCandidato.html">Candidato</a>: "fecha$cargo$nombreLista$DNI" | Ejemplo: "20111020$Intendente&amp;Lanus$UCR$34094150"<br/>
</li>
</ul>
<hr/>
 <h2><a class="anchor" id="ind"></a>
Índices</h2>
<h2><a class="anchor" id="hash"></a>
Hash:</h2>
<ul>
<li>Función de hashing utilizada:<br/>
<br/>
</li>
</ul>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash_extensible::funcion_hashing(<a class="code" href="classRegistroIndice.html" title="Registros utilizados por los índices implementados con el árbol B+ y el hash extensible.">RegistroIndice</a> *registro){

        <span class="keywordtype">string</span> clave = registro-&gt;<a class="code" href="classRegistroIndice.html#a9e398fb8bd9b8a93d98ecd3f4994c1c7" title="Devuelve la clave del registro.">getClave</a>();
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tam_tabla = obtener_tamanio_tabla();

        <span class="keywordtype">int</span> valor = 0;

   <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; clave.length() ; i++ )
        valor = 37 * valor + clave.at( i );

    valor %= tam_tabla;
    <span class="keywordflow">if</span>( valor &lt; 0 )
        valor += tam_tabla;

    <span class="keywordflow">return</span> valor + 1;
} 
</pre></div><p>En un principio usamos una función mucho más simple, que obtenía el valor ASCII de los caracteres de la clave, los sumaba, y luego calculaba el módulo de ese valor con el tamaño de la tabla de dispersión. Esa función dio malos resultados al intentar guardar grandes cantidades de registros en el hash, volviendo demasiado lenta y casi imposible la inserción de más de 500 registros, aproximadamente, debido a la cantidad de colisiones que se producían. <br/>
<br/>
</p>
<p>Con la actual función de hashing los resultados fueron mucho mejores, y pudimos insertar hasta 1 millón de registros en un tiempo de ejecución razonable.</p>
<ul>
<li>Tamaño de bloques:<br/>
<br/>
</li>
</ul>
<p>Para los bloques del hash elegimos un tamaño de 512 bytes, porque es un múltiplo de 512*2^n, al igual que los bloques en que está organizaod el disco, lo que permite aprovechar mejor el buffering del sistema.<br/>
 Además consideramos que es un tamaño adecuado a nuestras necesidades, ya que los bloques del hash almacenan objetos de la clase <a class="el" href="classRegistroIndice.html" title="Registros utilizados por los índices implementados con el árbol B+ y el hash extensible.">RegistroIndice</a>, que una vez persistidos con sus metadatos, ocupan un estimado de entre 13 y 18 bytes cada uno, y por lo tanto en cada bloque caben más de 30 registros.</p>
<h2><a class="anchor" id="arbol"></a>
Árbol B+:</h2>
<hr/>
 <h2><a class="anchor" id="bugs"></a>
Bugs conocidos</h2>
<p>Hash: <br/>
<br/>
</p>
<ul>
<li>Quedan algunas pérdidas de memoria sin resolver. Según las pruebas hechas, insertar 1 millón de registros de una vez consume 3 Gb de RAM. Sin embargo, para inserciones de menos de 300.000 elementos, la pérdida de memoria es mucho menor, y se pueden realizar sin problemas en una computadora con 2 o más Gb de RAM. Independientemente de la memoria del sistema, se puede guardar cualquier cantidad de registros, siempre y cuando no se los guarde a todos en una sola corrida (es decir, guardando algunos, cerrando el programa y guardando los que faltan).</li>
<li>Sí la cantidad de registros en el hash es demasiado alta (alrededor de 1 millón), el método imprimir no muestra correctamente la tabla de dispersión (se ve sólo una parte). Sin embargo la tabla en sí no tiene ninguna falla, por lo que el problema podría deberse a una limitación del editore de texto para escribir líneas demasiado largas. </li>
</ul>
</div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Oct 21 2011 21:26:29 for VotoElectronico by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
