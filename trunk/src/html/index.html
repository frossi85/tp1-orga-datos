<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VotoElectronico: Voto Electrónico</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VotoElectronico&#160;<span id="projectnumber">Entrega1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Voto Electrónico </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Grupo Furlong:</p>
<ul>
<li>Facundo Rossi (padrón 86.707 - <a href="mailto:frossi85@gmail.com">frossi85@gmail.com</a>)</li>
<li>Leandro Miguenz (padrón 90.649 - <a href="mailto:leandro.v.059@gmail.com">leandro.v.059@gmail.com</a>)</li>
<li>Martín Lucero (padrón 89.630 - <a href="mailto:don_pipa182@yahoo.com">don_pipa182@yahoo.com</a>)</li>
<li>Miguel Torres (padrón 91.396 - <a href="mailto:mat1204@hotmail.com">mat1204@hotmail.com</a>)<br/>
 <hr/>
</li>
</ul>
<h2><a class="anchor" id="primera"></a>
Primera Entrega</h2>
<h2><a class="anchor" id="imple"></a>
Implementación</h2>
<p>Debido a que la problemática que presentan las distintas entidades del dominio son diferentes, se utilizaran distintos tipo de organizaciones y estructuras de datos de acuerdo a la entidad. <br/>
<br/>
</p>
<p>Aparte del ID de cada entidad, se introducirá uno numérico (entero). De esta manera se lograra una mejor performance en búsquedas, y una implementación mas sencilla de los algoritmos de las estructuras de archivos.<br/>
 Además solucionaría problemas de tamaño de almacenamiento dados por almacenar entidades enteras dentro de otra entidad que las referencia, como es el caso de votante que contienen elecciones indefinidas. <br/>
<br/>
</p>
<p>Tanto el ID que agregamos nosotros, como el identificador de la clase (x ej en votante el DNI), no podrán tener duplicados. Por eso al realizar cualquier alta o modificación, se deberá comprobar que sean únicos. <br/>
<br/>
</p>
<p>Si se cambia el identificador (o parte de él) de una instancia particular de cualquier tipo de entidad, antes de eso se deberán actualizar los índices que relacionen la clave autonumerica con el identificador de la instancia, modificando este ultimo con el nuevo valor. Lo mismo si se borra una entidad, primero se actualizan los índices y luego se elimina.</p>
<h2><a class="anchor" id="orga"></a>
Organización</h2>
<p>Nueva definición de las entidades:<br/>
<br/>
</p>
<ul>
<li><a class="el" href="classDistrito.html">Distrito</a> (id, (distrito)i)</li>
<li><a class="el" href="classVotante.html">Votante</a> (id, (DNI)i, NombreyApellido, clave, domicilio, (idDistrito)ie, ((idEleccion)ie)*)</li>
<li><a class="el" href="classEleccion.html">Eleccion</a> (id, (fecha, (idCargo)ie)i, ((idDistrito)ie)+)</li>
<li><a class="el" href="classLista.html">Lista</a> (id, ((idEleccion)ie, nombre)i)</li>
<li><a class="el" href="classCandidato.html">Candidato</a> (id, ((idLista)ie, (idVotante)ie, (idCargo)ie)i)</li>
<li><a class="el" href="classCargo.html">Cargo</a> (id, (cargo)i, (cargo)*)</li>
<li><a class="el" href="classConteo.html">Conteo</a> (((idLista)ie, (idDistrito)ie, (idEleccion)ie)i, cantidad)</li>
<li><a class="el" href="classAdministrador.html">Administrador</a> ((usuario)i, clave) <br/>
 (<a class="el" href="classConteo.html">Conteo</a> no necesita id numérico ya que ninguna otra entidad tiene referencias a ella. Relacionamos directamente la clave con el offset en el archivo de conteos. Lo mismo para <a class="el" href="classAdministrador.html">Administrador</a>)</li>
</ul>
<p>Estructuras utilizadas:</p>
<p>Estructuras del TP (cuando se usa la palabra id, se refiere a la clave autonumerica):</p>
<p>1- Hash Votante/id =  clave: DNI (pasar de int a string), dato: id del votante <br/>
 2- Hash idVotante/offset =  clave: id_votante, dato: offset del votante en el archivo <br/>
</p>
<p>3- Hash Distrito/id = clave: nombreDistrito (string), dato: id del distrito<br/>
 4- Hash idDistrito/offset = clave: id_distrito, dato: offset del distrito en el archivo <br/>
</p>
<p>5- Hash Cargo/id = clave: cargoPrincipal (string), dato: id del cargo<br/>
 6- Hash idCargo/offset: clave: id_cargo, dato: offset del cargo en el archivo <br/>
</p>
<p>7- Arbol Candidato/id = clave: fecha$cargoPpal$nombreLista$DNI(string). dato: id del candidato<br/>
 8- Hash idCandidato/offset = clave: id_candidato, dato: offset del candidato en el archivo <br/>
</p>
<p>9- Arbol Lista/id = clave: fecha$cargoPpal$nombreLista. dato: id de la lista. (el $ es el símbolo que usamos para concatenar las cadenas)<br/>
 10- Hash idLista/offset = clave: id_lista, dato: offset de la lista en el archivo <br/>
</p>
<p>11- Arbol Eleccion/id = clave: fecha$cargoPrincipal . dato: id_eleccion.<br/>
 12- Hash idEleccion/offset = clave: id_eleccion . dato: offset en el archivo <br/>
</p>
<p>13- ARBOL REPORTE DISTRITO = clave: nom_distrito$fecha$cargoPrincipal$nom_lista. dato: offset del conteo en el archivo.<br/>
 14- ARBOL REPORTE LISTA = clave: fecha$cargoPrincipal$nom_lista$nom_distrito. dato: offset del conteo en el archivo.<br/>
 15- ARBOL REPORTE ELECCION = clave: fecha$cargoPrincipal$nom_distrito$nom_lista. dato: offset del conteo en el archivo.<br/>
</p>
<p>Todas las entidades se almacenan en archivos de registros de tamaño variable.<br/>
 En el caso de aquellas que implementan id numérico, se utiliza un hash para relacionar ese id con su correspondiente clave.<br/>
 Es decir que primero se le pasa su id a dicho hash para obtener la clave, y luego se le pasa esa clave al hash/árbol índice de esa entidad, para finalmente obtener el offset del registro en su archivo de registros variables. <br/>
<br/>
</p>
<p>Para las entidades que tienen más de un campo como identificador (Elección, <a class="el" href="classLista.html">Lista</a> y <a class="el" href="classCandidato.html">Candidato</a>), se utilizan índices B+, para aprovechar la posibilidad de hacer búsquedas aproximadas que brinda esa estructura. <a class="el" href="classDistrito.html">Distrito</a>, <a class="el" href="classVotante.html">Votante</a> y <a class="el" href="classCargo.html">Cargo</a> usan índices de dispersión extensible modular.</p>
<p>En el caso particular de <a class="el" href="classConteo.html">Conteo</a>, tiene tres índices B+, para posibilitar la recuperación de conteos por lista, distrito o elección, y usarlos para imprimir el reporte de resultados en base a alguno de esos tres criterios.<br/>
<br/>
</p>
<p>Los conteos se crean todos con cantidad 0 cuando se da de alta una lista. Cuando se confirma el voto del usuario, a partir de su distrito y de la lista que votó se obtiene el conteo correspondiente (buscándolo en el árbol) y se incrementa su cantidad de votos. <hr/>
<h2><a class="anchor" id="res"></a>
Resumen:</h2>
<ul>
<li>Los datos (las entidades propiamente dichas) se guardaran en archivos de registros variables o fijos (según de qué entidad se trate).</li>
<li>La búsqueda de estos datos se realizará mediante índices implementados con un hash extensible y un árbol B+, que van a guardar un par (clave, offset en archivo).</li>
<li>El flujo del programa tendría esta forma:<br/>
 1- el administrador ingresa una clave.<br/>
 2- el hash/árbol usado cómo índice recibe ese id, y devuelve un offset.<br/>
 3- se accede a ese offset para obtener el registro deseado.<br/>
 4- el administrador modifica el registro.<br/>
 5 - Se persisten los cambios, y si es necesario, se modifica el offset en el hash/árbol índice. <br/>
<br/>
 (Para altas, bajas y votaciones la estructura es similar).<br/>
 <hr/>
 </li>
</ul>
<h2><a class="anchor" id="notas"></a>
Sobre el formato de las claves</h2>
<p>Aclaraciones:<br/>
<br/>
</p>
<p>1 - Cuando se guarda una clave en el hash o arbol, antes se llama a Utilidaes::formatearClave(clave) para reemplazar los espacios por '&amp;'.<br/>
</p>
<p>2 - Para las claves con fechas, tambien antes de guardarlas se le hace a la fecha Utilidades::indexarFecha(fecha) para llevarla al formato aaaammdd (la fecha original ingresada por el administrador debe ser del formato ddmmaaaa o dd/mm/aaaa. No es valido un formato d/m/aaaa, es decir, debe completarse con ceros si es menor a 10.<br/>
   3 - También cuando una clave es compuesta, se concatenan los strings con '$'.<br/>
<br/>
</p>
<p>Ejemplo ilustrativo: el administrador habia insertado una lista con fecha "20/10/2011", cargo "Diputado Cordoba", nombre "UCR". El <a class="el" href="classABMentidades.html#ae133c835d245ddf83ca0d2facc8989ae">ABMentidades::altaLista</a> inserta la clave en la forma "20111020$Diputado&amp;Cordoba$UCR".<br/>
<br/>
</p>
<ul>
<li><a class="el" href="classDistrito.html">Distrito</a>: "nombre_distrito" | Ejemplo: "Lanus"<br/>
</li>
<li><a class="el" href="classCargo.html">Cargo</a>: "nombre_cargo" | Ejemplo: "Intendente&amp;Lanus"<br/>
</li>
<li><a class="el" href="classEleccion.html">Eleccion</a>: "fecha$cargo" | Ejemplo: "20111020$Intendente&amp;Lanus"<br/>
</li>
<li><a class="el" href="classLista.html">Lista</a>: "fecha$cargo$nombreLista" | Ejemplo: "20111020$Intendente&amp;Lanus$UCR"<br/>
</li>
<li><a class="el" href="classVotante.html">Votante</a>: "DNI" | Ejemplo: "34094150"<br/>
</li>
<li><a class="el" href="classCandidato.html">Candidato</a>: "fecha$cargo$nombreLista$DNI" | Ejemplo: "20111020$Intendente&amp;Lanus$UCR$34094150"<br/>
</li>
</ul>
<hr/>
 <h2><a class="anchor" id="ind"></a>
Índices</h2>
<h2><a class="anchor" id="hash"></a>
Hash:</h2>
<ul>
<li>Función de hashing utilizada:<br/>
<br/>
</li>
</ul>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classhash__extensible.html#a0456ecea4f18013d8fac2392fa7413ef">hash_extensible::funcion_hashing</a>(<a class="code" href="classRegistroIndice.html" title="Registros utilizados por los índices implementados con el árbol B+ y el hash extensible.">RegistroIndice</a> *registro){

        <span class="keywordtype">string</span> clave = registro-&gt;<a class="code" href="classRegistroIndice.html#a9e398fb8bd9b8a93d98ecd3f4994c1c7" title="Devuelve la clave del registro.">getClave</a>();
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tam_tabla = <a class="code" href="classhash__extensible.html#acf4823205a3cb26f6efce6a1e293f5d2">obtener_tamanio_tabla</a>();

        <span class="keywordtype">int</span> valor = 0;

   <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; clave.length() ; i++ )
        valor = 37 * valor + clave.at( i );

    valor %= tam_tabla;
    <span class="keywordflow">if</span>( valor &lt; 0 )
        valor += tam_tabla;

    <span class="keywordflow">return</span> valor + 1;
} 
</pre></div><p>En un principio usamos una función mucho más simple, que obtenía el valor ASCII de los caracteres de la clave, los sumaba, y luego calculaba el módulo de ese valor con el tamaño de la tabla de dispersión. Esa función dio malos resultados al intentar guardar grandes cantidades de registros en el hash, volviendo demasiado lenta y casi imposible la inserción de más de 500 registros, aproximadamente, debido a la cantidad de colisiones que se producían. <br/>
<br/>
</p>
<p>Con la actual función de hashing los resultados fueron mucho mejores, y pudimos insertar hasta 1 millón de registros en un tiempo de ejecución razonable.</p>
<ul>
<li>Tamaño de bloques:<br/>
<br/>
</li>
</ul>
<p>Para los bloques del hash elegimos un tamaño de 512 bytes, porque es un múltiplo de 512*2^n, al igual que los bloques en que está organizaod el disco, lo que permite aprovechar mejor el buffering del sistema.<br/>
 Además consideramos que es un tamaño adecuado a nuestras necesidades, ya que los bloques del hash almacenan objetos de la clase <a class="el" href="classRegistroIndice.html" title="Registros utilizados por los índices implementados con el árbol B+ y el hash extensible.">RegistroIndice</a>, que una vez persistidos con sus metadatos, ocupan un estimado de entre 13 y 18 bytes cada uno, y por lo tanto en cada bloque caben más de 30 registros.</p>
<h2><a class="anchor" id="arbol"></a>
Árbol B+:</h2>
<ul>
<li>Registros:<br/>
<br/>
</li>
</ul>
<p>El registro consta de 3 atributos, una clave(string), un offset u id(long) y un atributo denominado link (long) que es como indica su nombre es un link directo al registro indmediatamente mayor a él. Este último atributo se implementa para realizar el recorrido secuencial desde un registro en vez de hacerlo desde un nodo.<br/>
 Los unicos campos variables dentro los registros del árbol son las claves, que son del tipo string. Para este tipo de dato se graba el largo de la clave como un entero (int), sin contar el '/0'. Seguido de eso se procede a guardar cada caracter del string sin tener en cuenta el caracter de finalización. <br/>
<br/>
</p>
<ul>
<li>Nodos:<br/>
<br/>
</li>
</ul>
<p>El nodo posee como atributos su tamaño máximo, la cantidad de registros que puede albergar, los registros mismos, una dirección dentro del archivo del árbol, una dirección al padre, una al nodo inmediatamente menor y un flag que es utilizado para indicar si el nodo fue modificado después de leerlo del archivo del árbol. Este último es utilizado para implementar una política de caché tal que al leer un nodo, se guarda en memoria y mientras no se supere la cantidad máxima de nodos en memoria seteados por el árbol no se impacten los cambios, ni se lea un nodo desde el disco si está en cachá. Además se provee de un mecanismo interno que permite obligar a impactar los cambios y liberar. Este es útil en casos como por ejemplo al cerrar o eliminar el árbol.<br/>
 Como se describió antes, el encargado de saber la ubicación de un registro mayor, pertenece al registro mismo, por lo que no se incluye en el nodo el link al nodo hermano.<br/>
 Para la búsqueda de registros dentro de un nodo en memoria se utilizó búsqueda binaria, la cual en memoria es muy eficiente debido a que los registros estan ordenados.<br/>
<br/>
</p>
<ul>
<li>Reestructuración por overflow y underflow:<br/>
<br/>
</li>
</ul>
<p>El split y la combinación de nodos se realiza a nivel del árbol. Es decir que no es un método implementado en la clase <a class="el" href="classNodo.html">Nodo</a>.<br/>
 Para la combinación, se fusionan los dos nodos sobre el nodo izquierdo y se libera el nodo derecho. Esta operación de combinar nodo se utiliza por el rebalancear nodo, que va rebalancenado el árbol desde el primer nodo en el que hay que combinar un nodo hasta llegar a la raíz o que no halla que combinar.<br/>
 El split es similar, se busca el nodo donde debería insertarse el registro; si necesita ser partido, se parte y se extiende la partición desde el nodo hacia arriba o sus menores.</p>
<hr/>
 <h2><a class="anchor" id="bugs"></a>
Bugs conocidos</h2>
<p>Hash: <br/>
<br/>
</p>
<ul>
<li>Quedaron algunas pérdidas de memoria sin resolver. Según las pruebas hechas, insertar 1 millón de registros de una vez consume 3 Gb de RAM. Sin embargo, para inserciones de menos de 300.000 elementos, la pérdida de memoria es mucho menor, y se pueden realizar sin problemas en una computadora con 2 o más Gb de RAM. Independientemente de la memoria del sistema, se puede guardar cualquier cantidad de registros, siempre y cuando no se los guarde a todos en una sola corrida (es decir, guardando algunos, cerrando el programa y guardando los que faltan). <br/>
<br/>
</li>
</ul>
<p>Votación: <br/>
<br/>
</p>
<ul>
<li>El método getListaPorEleccion() está devolviendo las listas de la elección que recibe por parámetro y de la siguiente elección en fecha. Puede deberse a una inconsistencia de datos de la carga inicial, no se llegó a corroborar.<br/>
<br/>
</li>
</ul>
<p><br/>
<br/>
<br/>
 <hr/>
 Aclaración importante:<br/>
<br/>
</p>
<p>No es posible cambiar la fecha ni el cargo principal de una elección, ni agregarle cargos secundarios. Si se quieren agregar, debe hacerse desde el modificar de <a class="el" href="classCargo.html">Cargo</a>. Es decir, la opción de agregar cargos secundarios no debería estar en el modificar de Elección, sino sólo en el de <a class="el" href="classCargo.html">Cargo</a>, pero por cuestiones de tiempo no llegamos a eliminar dicha opción del menu.<br/>
 Por otra parte, el modificar de Elección sí permite agregar o quitar distritos.</p>
<hr/>
 <h2><a class="anchor" id="segunda"></a>
Segunda Entrega</h2>
<p>Para esta entrega se agregó funcionalidad al trabajo práctico para realizar la encriptación de la información de votantes y administradores usando <a class="el" href="classRSA.html">RSA</a>, y la encriptación de los reportes mediante el algoritmo de <a class="el" href="classVigenere.html">Vigenere</a>.<br/>
 El algoritmo <a class="el" href="classRSA.html">RSA</a> genera las claves pública y privada siguiendo el procedimiento de multiplicación de números primos visto en clase.<br/>
 También se agregaron opciones para romper dichos criptogramas usando factorización de números primos y el algoritmo de <a class="el" href="classKasiski.html">Kasiski</a>, respectivamente.<br/>
 A excepción de la utilización de <a class="el" href="classRSA.html">RSA</a>, que es transparente al usuario, el resto de la funcionalidad se agregó en forma de nuevas opciones en el menú del administrador, o que se acceden mediante ciertos argumentos por línea de comandos. Su uso se explica a continuación.</p>
<h2><a class="anchor" id="uso"></a>
Modos de uso</h2>
<h2><a class="anchor" id="carga"></a>
Carga inicial:</h2>
<p>Para tener datos cargados en el programa, de manera tal que se puedan probar todas sus características sin tener que crear entidades ni votar manualmente, se pueden usar las opciones de carga inicial y votante automático de la siguiente manera: <br/>
<br/>
</p>
<p>./VotoElectronico -c <br/>
 ./VotoElectronico -v <br/>
<br/>
</p>
<h2><a class="anchor" id="romperRSA"></a>
Romper RSA:</h2>
<p>Para probar el algoritmo de factorización, se debe ejecutar el programa por línea de comandos de la siguiente forma: <br/>
<br/>
</p>
<p>./VotoElectronico --romperRSA <br/>
<br/>
</p>
<p>Por pantalla se mostrarán los pasos seguidos por el algoritmo y sus resultados. Para romper la encriptación de <a class="el" href="classRSA.html">RSA</a> se utiliza factorización de números primos (ver clase <a class="el" href="classFactorizacion.html">Factorizacion</a>), aplicando divisiones sucesivas y el método de Fermat. El método encargado de esta tarea es <a class="el" href="classRSA.html#a840cff81e5df8b0763b36dd92616b881">RSA::romper</a>.</p>
<h2><a class="anchor" id="encriptar"></a>
Encriptación/rotura de reportes con Vigenère y Kasiski:</h2>
<p>Antes de empezar a trabajar con los reportes, estos deben ser generados. Para hacerlo, hay que ingresar como administrador (recordar que por defecto se puede usar la cuenta con usuario y contraseña "tp"), en el menú seleccionar la opción "R" (Informes de resultados), y en el submenú que aparece, elegir alguno de los 3 tipos de reportes para ver. El reporte elegido se mostrará por pantalla, y además se guardará en un archivo de texto en la carpeta src/Reportes.</p>
<p>Una vez que haya algún reporte, hay que acceder como administrador, y en el menú principal seleccionar la opción "G" (Encriptar/Desencriptar/Romper Reportes). En el submenú que aparece figuran tres opciones: <br/>
<br/>
</p>
<ul>
<li>Encriptar: se pide una clave de encriptación, la ruta del archivo a encriptar, y la ruta donde se desea guardar el criptograma (que puede ser la misma). Vale la pena aclarar que cuando se ingresa la ruta, se debe considerar que "./" 'apunta' al directorio del programa ejecutable. Como los reportes se encuentran en una carpeta "Reportes" dentro del directorio donde se encuentra el ejecutable, entonces la ruta sería "./Reportes/ReporteDistrito", por ejemplo. Cuando se pide el archivo sin encriptar para encriptar (o cuando se pide el encriptado para desencriptar), este debe existir. De lo contrario, se mostrará un mensaje de error. Cuando se pide la ruta para generar el archivo encriptado (o generear el desencriptado), en caso de existir ya un archivo con el nombre que se ingresa, este se sobreescribe. La clave puede tener sólo caracteres ascii de 7 bits (es decir, no ascii extendido). Esto se debe a que esta implementación del algoritmo realiza las operaciones en módulo 127 (usa una tabla de 127 símbolos para los reemplazos). Ya que la idea de la encriptación en este caso es aplicarla cuando se quiere mandar el reporte a alguien, y para facilitar la observación del funcionamiento de los algoritmos, se decidió que en principio el reporte se guarde como texto plano sin encriptar.</li>
</ul>
<ul>
<li>Desencriptrar: el funcionamiento es análogo al de la opción anterior.</li>
</ul>
<ul>
<li>Romper: también se pide una ruta de origen y una de destino. Si el archivo de origen (el criptograma) no existiese, se mostrará un mensaje de error. En la primera línea del archivo generado se muestra cuál era la clave de encriptación. Puede pasar que para un determinado criptograma, el método no sea efectivo y el archivo obtenido resulte total o parcialmente ilegible. En la entrega se incluye el criptograma de ejemplo "EjemploParaKasiski" en la carpeta Reportes, para que se pueda probar este algoritmo en un caso en el que sabemos que cumple su cometido. Al igual que Vigenère, la implementación de este algoritmo trabaja con los primeros 127 ascii. Básicamente, el funcionamiento es el siguiente: se aplica el método de <a class="el" href="classKasiski.html">Kasiski</a> para determinar la longitud de la clave. Luego se alinea el criptograma en n columnas, siendo n dicha longitud, y en cada columna se hace un análisis de frecuencias. Se asume que el caracter que aparezca más veces se corresponde con el espacio (' '). También se generan posibles claves probando reemplazar ese caracter por 'e' y 'a', en ese orden, ya que son los que aparecen con más frecuencia en un texto en castellano. Se realiza la resta de los valores ascii de esos caracteres, y se obtiene el primer caracter de la clave. Repitiendo el proceso con las demás columnas se obtiene el resto de la clave. Al terminar este proceso, se tienen 3 claves posibles (una por cada reemplazo probado). Finalmente se usa cada clave para desencriptar el texto (se generan 3 archivos "desencriptados"). El algoritmo recorre esos tres archivos, busca las palabras clave (eleccion, lista, distrito, etc.), y deja sólo aquel en el que estas palabras aparezcan más veces, borrando los demás. </li>
</ul>
</div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Dec 3 2011 22:42:55 for VotoElectronico by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
